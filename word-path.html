<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="./css/projects-long-format.css" />
  </head>
  <body>
    <h1>Word path game</h1>
    <h2>What is it?</h2>
    <p>
      This is web implementation of the word game Boggle. It lets players
      generate new games with a 16 die grid that uses their selected number of
      vowels (using more or fewer vowels makes it harder), then runs a timer
      while players find as many words as possible in the grid. At the end of
      the game, players can display a list of all the possible words in the
      current game and see the maximum possible score.
    </p>
    <h2>How does it work?</h2>
    <p>
      When you open the webpage, a new game is generated by shuffling the dies
      and showing them on the screen. If you prefer, you can change the number
      of vowels you want in the puzzle, and a new game will be created with that
      number of vowels (games with either very low or very high numbers of
      vowels can be harder). You then start the built-in timer and write down
      all words you find following the rules of Boggle (consecutive letters in
      words can connect in any direction, including diagonally, but each die can
      only be used once in each word). When the time expires, count and score
      the words you found. Then you can click on the checkbox to show the full
      list of words found in the puzzle and the maximum possible score. Clicking
      on any of the words in the list highlights how it can be formed in the
      current puzzle. How well did you do?
    </p>
    <h2>How is it built?</h2>
    <p>
      To make this, I used a web worker that loaded a list of English words that
      will be used to solve the game in the background so that it did not affect
      any of the other game rendering. Each of the dice has the same letter
      faces as in the physical game, and this came with some extra edge case
      handling required for the 'Qu' dice face having two letters instead of the
      usual one, and one of the dies not having any vowels.
      <br />
      I used a list of lists as the data structure to represent the 2-D board
      when shuffling for a new game, displaying the current game, and solving
      the game to show all the words that it contains. For this solving, nested
      for loops and repeated function calls are used to find all the words in
      the given game by tracing potential paths letter-by-letter. This is set up
      to ensure that smaller words found inside larger words (e.g. 'home' and
      'unfathomed') are counted as independent words This also keeps a record of
      the path each word forms through the game, so the path for each word can
      be highlighted when the player clicks on its entry in the list of words
      found in the game.
      <br />
      A suite of functions using setInterval provide the ability to start, stop,
      re-start, and clear the built-in game timer. Other functions toggle
      highlighting the path taken to form a particular word in the grid when the
      user clicks that word in the solved word list, and allow sorting the
      solved word list either alphabetically (to find a particular word easily),
      or by the order that their first letters appear in the game grid (to see
      all words that start at a given die).
    </p>
    <h2>Why did I build it?</h2>
    <p>
      My family likes playing the word game Boggle, where you find as many words
      as you can by connecting letters on 16 dice that can be shuffled each
      game. When playing Boggle, I've always been fascinated by how many words
      can be in certain game that some people see and other people don't. That
      got me curious to make a website that allows you to play Boggle and then
      show all of the possible words that were in the grid so you can see how
      many of the possible words were spotted by players during that round, and
      what the maximum possible score was. While I was building that, I also
      wanted to allow the player to customize the die shuffle for each game so
      that their requested number of vowels was guaranteed. This is sometimes a
      frustration when playing with physical dies, where you have to roll
      several games before one comes up with enough vowels to be fun to play.
    </p>
    <h2>Project design</h2>
    <p>
      The basic project design was to include the grid of letters that could be
      re-shuffled to provide an online Boggle game, and that would be solved by
      the computer to show a list of all possible words and the maximum possible
      score. As I was building it, I continued thinking of other enhancements
      that would extend it functionality in related ways that would make it a
      more capable app. The integrated timer, ability to include different
      numbers of vowels in each game, the color-coded trace of each word found
      in the game when it's clicked in the word list, and the ability to sort
      the word list either alphabetically or by die of the first letter in the
      game are all features that I added to the project after building out the
      initial design.
    </p>
    <h2>What I am most proud of</h2>
    <p>
      I am most proud of the automatic solving capability of this app. I
      especially like how it can easily highlight the path of any found word in
      the grid, to see how especially long words or words with complex paths are
      represented in the puzzle, and the tally of the maximum total score for
      each game so you can see how well you did.
    </p>
    <h2>Challenges I ran into and how I resolved them</h2>
    <p>
      After seeing how slowly the first iteration of the word finding algorithm
      worked when trying to find words through all combinations of neighboring
      letters, I created a heuristic method to speed it up. For this, I first
      created a list of all 2-letter stems represented in English words. I then
      used that list to screen initial paths by looking at the letters
      surrounding each presumptive first word letter. For each combination of
      potential first and second letter, I dropped any that were not in the list
      of 2-letter stems from any path tracing, and only kept those whose stems
      could lead to English words for further traversing. This modification
      reduced the search space required and increased the solve speed
      considerably.
      <br />
      Due to design of Boggle, there are also two edge cases with dies that need
      to be accounted for: one die has two letters on its face for 'Qu', and
      another die does not have any vowels on its faces. To accommodate the 'Qu'
      face, I made sure it was rendered correctly in the board with a lowercase
      'u', and counted the combination as a single letter when finding the
      two-letter word stems to determine possible word paths to explore. For the
      die without any vowels, I needed to prevent its use when choosing the
      vowel die added its array representation as the last entry to a holder
      array representing all dies and then only iterated through the 0th to the
      n-1th die elements of that array when shuffling the array to include the
      user-selected number of vowels
    </p>
    <h2>What I learned for future projects</h2>
    <p>
      Through this project I learned how to use web workers to load needed
      information for the webpage, in this case the word list, without blocking
      JavaScript's execution thread, how to do word lookups using a heuristic to
      speed up the process, working with two dimensional arrays and tracing
      paths through them.
    </p>
  </body>
</html>
